Problem Statement

You are given an integer array nums that was originally sorted in ascending order, but then rotated at some pivot index k (0 ≤ k < nums.length).

So the array looks like this:

[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]


You are also given an integer target.

Your task is to:

Return the index of target in the array nums if it exists, otherwise return -1.

You must design an algorithm that runs in O(log n) time.

Input Format (conceptual)

For the function, assume you are given:

int Search(int[] nums, int target)


No need to handle console input — just implement this function.

Output Format

Return an integer:

The index of target in nums if found

-1 if target is not present

Examples
Example 1
nums   = [4,5,6,7,0,1,2]
target = 0


Output:

4


Explanation: nums[4] == 0

Example 2
nums   = [4,5,6,7,0,1,2]
target = 3


Output:

-1

Example 3
nums   = [1]
target = 0


Output:

-1

Constraints
1 ≤ nums.length ≤ 10^4
-10^4 ≤ nums[i] ≤ 10^4
All values in nums are **unique**
nums is rotated at some pivot (maybe 0 → not rotated)


Time: O(log n) expected (binary search).
Straight linear scan O(n) works logically but not ideal in an interview.