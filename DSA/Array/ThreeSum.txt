Problem Statement

Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that:

i, j, and k are all different indices

nums[i] + nums[j] + nums[k] == 0

The result must not contain duplicate triplets.

Triplets should be returned in any order, but:

Within a triplet, the numbers should be in non-decreasing order (e.g., [-1, 0, 1], not [1, -1, 0]).

The set of triplets must be unique (no repeated [-1, 0, 1] in the result).

Input Format

You can assume input is like:

n
a0 a1 a2 ... a(n-1)


n → size of the array

second line → n space-separated integers = nums[i]

For the function you implement, you just receive int[] nums.

Output Format

Your function should return a list of triplets, i.e., IList<IList<int>> in C#.

On platforms like HackerRank, they’ll usually format and print your result.
You only need to produce the correct data structure.

Constraints
0 ≤ n ≤ 10^4
-10^9 ≤ nums[i] ≤ 10^9


Time complexity target: O(n^2) using sorting + two pointers.
A naive O(n^3) triple loop may time out on the upper constraints.

Example 1
Input
nums = [-1, 0, 1, 2, -1, -4]

Possible Output
[
  [-1, -1,  2],
  [-1,  0,  1]
]


Explanation:

The triplets summing to 0 are:

[-1, -1, 2]

[-1, 0, 1]

[-1, 1, 0] is not considered different from [-1, 0, 1] → order inside triplet doesn’t matter, so we keep just one version.

Example 2
Input
nums = [0, 1, 1]

Output
[]


No triplet sums to 0.

Example 3
Input
nums = [0, 0, 0, 0]

Output
[
  [0, 0, 0]
]


Even though there are multiple 0’s, the triplet [0, 0, 0] should appear only once.

What you should implement

Write a method like this:

public static IList<IList<int>> ThreeSum(int[] nums)
{
    // your logic
}